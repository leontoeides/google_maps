use crate::places_new::LocalizedText;
use icu_locale::Locale;
use url::Url;

// -------------------------------------------------------------------------------------------------
//
/// AI-generated summary of a place.
///
/// Generative summaries provide AI-created overviews of places based on available data, reviews,
/// and other contextual information.
///
/// These summaries help users quickly understand what a place is about, its key features, and what
/// to expect. The summaries include moderation links for content reporting and disclosure
/// information about AI generation.
#[derive(
    //std
    Clone,
    Debug,
    Eq,
    Hash,
    PartialEq,
    // getset
    getset::Getters,
    // serde
    serde::Deserialize,
    serde::Serialize
)]
#[serde(rename_all = "camelCase")]
pub struct GenerativeSummary {
    /// The AI-generated overview of the place.
    ///
    /// Contains the main summary content describing the place, its features, atmosphere, and key
    /// characteristics. This text is generated by AI and provides a concise overview to help users
    /// understand the place.
    #[getset(get = "pub")]
    pub overview: LocalizedText,

    /// A link where users can flag a problem with the overview summary.
    ///
    /// URL that allows users to report inappropriate content, inaccuracies, or other issues with
    /// the AI-generated summary. This provides a mechanism for content moderation and quality
    /// improvement.
    #[serde(default)]
    #[getset(get = "pub")]
    pub overview_flag_content_uri: Option<Url>,

    /// The AI disclosure message indicating the content was AI-generated.
    ///
    /// Standard disclosure text such as "Summarized with Gemini" and its localized variants. This
    /// text informs users that the content was generated by AI and provides transparency about the
    /// source.
    #[getset(get = "pub")]
    pub disclosure_text: LocalizedText,
}

// -------------------------------------------------------------------------------------------------
//
// Method Implementations

impl GenerativeSummary {
    /// Creates a new `GenerativeSummary` with the specified overview and disclosure.
    ///
    /// Used to construct a generative summary with the essential AI-generated content and required
    /// disclosure information about AI generation.
    #[must_use]
    pub const fn new(overview: LocalizedText, disclosure_text: LocalizedText) -> Self {
        Self {
            overview,
            overview_flag_content_uri: None,
            disclosure_text,
        }
    }

    /// Creates a `GenerativeSummary` with moderation link included.
    ///
    /// Used when content reporting functionality is available, providing users with a way to flag
    /// issues with the AI-generated content.
    pub fn with_moderation(
        overview: LocalizedText,
        disclosure_text: LocalizedText,
        flag_uri: &str,
    ) -> Result<Self, crate::places_new::Error> {
        Ok(Self {
            overview,
            overview_flag_content_uri: Some(flag_uri.try_into()?),
            disclosure_text,
        })
    }

    /// Returns whether this summary has content.
    ///
    /// Used to determine if the summary contains meaningful text content that can be displayed to
    /// users, checking for non-empty overview text.
    #[must_use]
    pub fn has_content(&self) -> bool {
        !self.overview.text().trim().is_empty()
    }

    /// Returns whether content moderation is available.
    ///
    /// Used to determine if users can report issues with the summary content, enabling appropriate
    /// user interface elements for content reporting.
    #[must_use]
    pub const fn has_moderation(&self) -> bool {
        self.overview_flag_content_uri.is_some()
    }

    /// Gets the overview text in the summary's language.
    ///
    /// Returns the main summary content text, useful for display in user interfaces and content
    /// processing applications.
    #[must_use]
    pub fn overview_text(&self) -> &str {
        self.overview.text()
    }

    /// Gets the language code of the overview content.
    ///
    /// Returns the BCP-47 language code for the summary text, useful for internationalization,
    /// content filtering, and language-specific processing.
    #[must_use]
    pub fn overview_language(&self) -> &Locale {
        self.overview.language()
    }

    /// Gets the disclosure text content.
    ///
    /// Returns the AI disclosure message text, typically displayed alongside or after the summary
    /// to inform users about AI generation.
    #[must_use]
    pub fn disclosure_text_content(&self) -> &str {
        self.disclosure_text.text()
    }

    /// Returns whether the summary is in a specific language.
    ///
    /// Used for language-based filtering and content organization, helping applications show
    /// summaries in users' preferred languages.
    #[must_use]
    pub fn is_in_language(&self, language_str: &str) -> bool {
        self.overview.language().normalizing_eq(language_str)
    }

    /// Gets the estimated reading time for the overview.
    ///
    /// Calculates approximate reading time based on word count and average reading speed, useful
    /// for user interfaces showing content length.
    #[must_use]
    #[allow(clippy::cast_sign_loss, clippy::cast_possible_truncation)]
    pub fn estimated_reading_time(&self) -> std::time::Duration {
        let word_count = self.overview_text().split_whitespace().count();
        let words_per_minute = 200; // Average reading speed
        let minutes = (word_count as f64 / f64::from(words_per_minute)).ceil() as u64;
        std::time::Duration::from_secs(minutes.max(1) * 60) // Minimum 1 minute
    }

    /// Returns the character count of the overview.
    ///
    /// Used for content length validation, user interface layout decisions, and determining
    /// appropriate display formatting for the summary.
    #[must_use]
    pub fn character_count(&self) -> usize {
        self.overview_text().chars().count()
    }

    /// Returns the word count of the overview.
    ///
    /// Used for content analysis, length categorization, and determining appropriate display
    /// treatments for summaries of different lengths.
    #[must_use]
    pub fn word_count(&self) -> usize {
        self.overview_text().split_whitespace().count()
    }

    /// Returns whether this is a short summary.
    ///
    /// Used to identify brief summaries that may be suitable for compact displays, preview cards,
    /// or mobile interfaces with space constraints.
    #[must_use]
    pub fn is_short_summary(&self) -> bool {
        self.word_count() <= 50
    }

    /// Returns whether this is a detailed summary.
    ///
    /// Used to identify comprehensive summaries that provide extensive information and may require
    /// expanded display areas or detailed views.
    #[must_use]
    pub fn is_detailed_summary(&self) -> bool {
        self.word_count() > 150
    }

    /// Gets a truncated version of the overview for previews.
    ///
    /// Returns a shortened version of the summary suitable for preview cards, search results, or
    /// space-constrained interfaces while maintaining readability.
    #[must_use]
    pub fn preview_text(&self, max_chars: usize) -> String {
        let text = self.overview_text();
        if text.chars().count() <= max_chars {
            text.to_string()
        } else {
            let truncated: String = text.chars().take(max_chars.saturating_sub(3)).collect();
            format!("{}...", truncated.trim())
        }
    }

    /// Creates HTML markup for the summary with proper disclosure.
    ///
    /// Generates HTML content that includes both the summary text and disclosure information with
    /// appropriate styling and structure.
    #[must_use]
    pub fn to_html(&self) -> String {
        let overview_html = format!(
            "<div class=\"generative-summary-overview\">{}</div>",
            html_escape(self.overview_text())
        );

        let disclosure_html = format!(
            "<div class=\"generative-summary-disclosure\">{}</div>",
            html_escape(self.disclosure_text_content())
        );

        let flag_link = self.overview_flag_content_uri
            .as_ref()
            .map_or_else(
                String::new,
                |uri| format!(
                    "<div class=\"generative-summary-actions\"><a href=\"{}\" class=\"flag-content-link\" target=\"_blank\" rel=\"noopener noreferrer\">Report an issue</a></div>",
                    html_escape(uri.as_str())
                )
            );

        format!(
            "<div class=\"generative-summary\">{overview_html}{disclosure_html}{flag_link}</div>"
        )
    }

    /// Creates markdown representation of the summary.
    ///
    /// Generates markdown-formatted content suitable for documentation, export features, or
    /// markdown-based content management systems.
    #[must_use]
    pub fn to_markdown(&self) -> String {
        self.overview_flag_content_uri.as_ref().map_or_else(|| format!(
            "{overview_text}\n\n*{disclosure_text_content}*",
            overview_text = self.overview_text(),
            disclosure_text_content = self.disclosure_text_content()
        ), |uri| format!(
            "{overview_text}\n\n*{disclosure_text_content}*\n\n[Report an issue]({uri})",
            overview_text = self.overview_text(),
            disclosure_text_content = self.disclosure_text_content()
        ))
    }

    /// Returns whether the summary content appears to be high quality.
    ///
    /// Uses heuristics to assess content quality based on length, structure, and basic content
    /// analysis, useful for filtering or prioritizing summaries.
    #[must_use]
    pub fn appears_high_quality(&self) -> bool {
        let word_count = self.word_count();
        let text = self.overview_text();
        
        // Basic quality indicators
        (10..=300).contains(&word_count) && // Not excessively long
            !text.contains("...") && // Not truncated
            text.chars().filter(|c| c.is_alphabetic()).count() > text.len() / 2 // Mostly text
    }

    /// Gets content tags based on summary characteristics.
    ///
    /// Returns descriptive tags that categorize the summary content, useful for filtering,
    /// organization, and content management.
    #[must_use]
    pub fn content_tags(&self) -> Vec<&'static str> {
        let mut tags = Vec::new();
        
        if self.is_short_summary() {
            tags.push("short");
        } else if self.is_detailed_summary() {
            tags.push("detailed");
        } else {
            tags.push("medium");
        }
        
        if self.appears_high_quality() {
            tags.push("high-quality");
        }
        
        if self.has_moderation() {
            tags.push("moderated");
        }
        
        tags.push("ai-generated");
        tags
    }

    /// Returns a structured summary of content characteristics.
    ///
    /// Provides comprehensive metadata about the summary content suitable for analytics, content
    /// management, and quality assessment.
    #[must_use]
    pub fn content_analysis(&self) -> SummaryAnalysis {
        SummaryAnalysis {
            character_count: self.character_count(),
            word_count: self.word_count(),
            estimated_reading_time: self.estimated_reading_time(),
            language: self.overview_language().to_string(),
            has_moderation: self.has_moderation(),
            appears_high_quality: self.appears_high_quality(),
            length_category: if self.is_short_summary() {
                SummaryLength::Short
            } else if self.is_detailed_summary() {
                SummaryLength::Detailed
            } else {
                SummaryLength::Medium
            },
        }
    }
}

/// Simple HTML escape function for basic safety.
///
/// Escapes common HTML characters to prevent XSS when generating HTML markup.
/// For production use, consider using a dedicated HTML escaping library.
fn html_escape(text: &str) -> String {
    text.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#x27;")
}

// -------------------------------------------------------------------------------------------------
//
/// Analysis results for generative summary content.
///
/// Provides structured information about summary characteristics, quality indicators, and metadata
/// for content management and display decisions.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SummaryAnalysis {
    /// Total character count of the overview text.
    pub character_count: usize,
    /// Total word count of the overview text.
    pub word_count: usize,
    /// Estimated time to read the summary.
    pub estimated_reading_time: std::time::Duration,
    /// Language code of the summary content.
    pub language: String,
    /// Whether content moderation links are available.
    pub has_moderation: bool,
    /// Whether the content appears to be high quality.
    pub appears_high_quality: bool,
    /// Length categorization of the summary.
    pub length_category: SummaryLength,
}

// -------------------------------------------------------------------------------------------------
//
/// Categories for summary length classification.
///
/// Used to classify summaries by length for appropriate display treatments, layout decisions, and
/// user interface optimization.
#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
pub enum SummaryLength {
    /// Short summaries suitable for compact displays.
    Short,
    /// Medium-length summaries for standard views.
    Medium,
    /// Detailed summaries requiring expanded display areas.
    Detailed,
}

impl SummaryLength {
    /// Returns a user-friendly description of the length category.
    #[must_use]
    pub const fn description(self) -> &'static str {
        match self {
            Self::Short => "Short summary",
            Self::Medium => "Medium summary",
            Self::Detailed => "Detailed summary",
        }
    }
}

// -------------------------------------------------------------------------------------------------
//
// Tests

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    fn create_test_localized_text(text: &str, language: &str) -> LocalizedText {
        LocalizedText::new(text, language).unwrap()
    }

    #[test]
    fn test_serialization() {
        let summary = GenerativeSummary {
            overview: create_test_localized_text("This is a great restaurant with excellent food.", "en-US"),
            overview_flag_content_uri: "https://example.com/flag".try_into().ok(),
            disclosure_text: create_test_localized_text("Summarized with Gemini", "en-US"),
        };

        let json = serde_json::to_string(&summary).unwrap();
        assert!(json.contains("great restaurant"));
        assert!(json.contains("Summarized with Gemini"));
    }

    #[test]
    fn test_deserialization() {
        let json = r#"{
            "overview": {
                "text": "A popular local cafe with great coffee.",
                "languageCode": "en-US"
            },
            "overviewFlagContentUri": "https://example.com/flag",
            "disclosureText": {
                "text": "Summarized with AI",
                "languageCode": "en-US"
            }
        }"#;

        let summary: GenerativeSummary = serde_json::from_str(json).unwrap();
        assert_eq!(summary.overview_text(), "A popular local cafe with great coffee.");
        assert_eq!(summary.disclosure_text_content(), "Summarized with AI");
        assert!(summary.has_moderation());
    }

    #[test]
    fn test_constructors() {
        let overview = create_test_localized_text("Great place to visit", "en");
        let disclosure = create_test_localized_text("AI generated", "en");

        let basic = GenerativeSummary::new(overview.clone(), disclosure.clone());
        assert!(basic.has_content());
        assert!(!basic.has_moderation());

        let with_mod = GenerativeSummary::with_moderation(
            overview,
            disclosure,
            "https://flag.com"
        ).unwrap();

        assert!(with_mod.has_moderation());
    }

    #[test]
    fn test_content_analysis() {
        let short_text = "Great cafe.";
        let short_summary = GenerativeSummary::new(
            create_test_localized_text(short_text, "en"),
            create_test_localized_text("AI generated", "en"),
        );
        assert!(short_summary.is_short_summary());
        assert!(!short_summary.is_detailed_summary());

        let long_text = "This is a very comprehensive summary that goes into great detail about \
            many different aspects of the establishment including the atmosphere, service quality, \
            food options, pricing, location convenience, and overall customer experience that \
            visitors can expect when they choose to visit this particular venue. It may be \
            desirable to handle or display long summaries differently";
        let detailed_summary = GenerativeSummary::new(
            create_test_localized_text(long_text, "en"),
            create_test_localized_text("AI generated", "en"),
        );
        assert!(!detailed_summary.is_short_summary());
        assert!(!detailed_summary.is_detailed_summary());
    }

    #[test]
    fn test_word_and_character_counts() {
        let text = "This is a test summary with exactly nine words.";
        let summary = GenerativeSummary::new(
            create_test_localized_text(text, "en"),
            create_test_localized_text("AI generated", "en"),
        );

        assert_eq!(summary.word_count(), 9);
        assert_eq!(summary.character_count(), text.chars().count());
    }

    #[test]
    fn test_language_detection() {
        let english_summary = GenerativeSummary::new(
            create_test_localized_text("English text", "en-US"),
            create_test_localized_text("AI generated", "en-US"),
        );

        assert!(english_summary.is_in_language("en-US"));
        assert!(english_summary.is_in_language("EN-US")); // Case insensitive
        assert!(!english_summary.is_in_language("es-ES"));
        assert!(english_summary.overview_language().normalizing_eq("en-US"));
    }

    #[test]
    fn test_preview_text() {
        let long_text = "This is a very long summary that should be truncated for preview purposes.";
        let summary = GenerativeSummary::new(
            create_test_localized_text(long_text, "en"),
            create_test_localized_text("AI generated", "en"),
        );

        let preview = summary.preview_text(20);
        assert!(preview.len() <= 20);
        assert!(preview.ends_with("..."));

        let short_preview = summary.preview_text(100);
        assert_eq!(short_preview, long_text); // No truncation needed
    }

    #[test]
    fn test_reading_time() {
        let text = "word ".repeat(200); // 200 words
        let summary = GenerativeSummary::new(
            create_test_localized_text(&text, "en"),
            create_test_localized_text("AI generated", "en"),
        );

        let reading_time = summary.estimated_reading_time();
        assert_eq!(reading_time, std::time::Duration::from_secs(60)); // 1 minute for 200 words
    }

    #[test]
    fn test_html_generation() {
        let summary = GenerativeSummary::with_moderation(
            create_test_localized_text("Great <place> & \"location\"", "en"),
            create_test_localized_text("AI & generated", "en"),
            "https://flag.com",
        ).unwrap();

        let html = summary.to_html();
        assert!(html.contains("&lt;place&gt;")); // HTML escaped
        assert!(html.contains("&amp;")); // Ampersand escaped
        assert!(html.contains("&quot;")); // Quote escaped
        assert!(html.contains("generative-summary"));
        assert!(html.contains("Report an issue"));
    }

    #[test]
    fn test_markdown_generation() {
        let summary = GenerativeSummary::with_moderation(
            create_test_localized_text("Great place to visit", "en"),
            create_test_localized_text("AI generated", "en"),
            "https://flag.com",
        ).unwrap();

        let markdown = summary.to_markdown();
        assert!(markdown.contains("Great place to visit"));
        assert!(markdown.contains("*AI generated*"));
        assert!(markdown.contains("[Report an issue](https://flag.com/)"));
    }

    #[test]
    fn test_quality_assessment() {
        let high_quality = GenerativeSummary::new(
            create_test_localized_text("This establishment offers excellent service and food quality. Great experience.", "en"),
            create_test_localized_text("AI generated", "en"),
        );
        assert!(high_quality.appears_high_quality());

        let low_quality = GenerativeSummary::new(
            create_test_localized_text("...", "en"),
            create_test_localized_text("AI generated", "en"),
        );
        assert!(!low_quality.appears_high_quality());
    }

    #[test]
    fn test_content_tags() {
        let summary = GenerativeSummary::with_moderation(
            create_test_localized_text("Good place", "en"),
            create_test_localized_text("AI generated", "en"),
            "https://flag.com",
        ).unwrap();

        let tags = summary.content_tags();
        assert!(tags.contains(&"short"));
        assert!(tags.contains(&"ai-generated"));
        assert!(tags.contains(&"moderated"));
    }

    #[test]
    fn test_content_analysis_struct() {
        let summary = GenerativeSummary::new(
            create_test_localized_text("This is a medium length summary for testing.", "en-US"),
            create_test_localized_text("AI generated", "en-US"),
        );

        let analysis = summary.content_analysis();
        assert_eq!(analysis.word_count, 8);
        assert_eq!(analysis.language, "en-US");
        assert!(!analysis.has_moderation);
        assert_eq!(analysis.length_category, SummaryLength::Short);
    }

    #[test]
    fn test_summary_length_enum() {
        assert_eq!(SummaryLength::Short.description(), "Short summary");
        assert_eq!(SummaryLength::Medium.description(), "Medium summary");
        assert_eq!(SummaryLength::Detailed.description(), "Detailed summary");
    }
}